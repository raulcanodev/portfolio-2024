import { c as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_C0avBOm-.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<h2 id=\"index\">Index</h2>\n<ul>\n<li><a href=\"#big-o-notation\">Big O Notation</a></li>\n<li><a href=\"#time-complexity\">Time Complexity</a></li>\n<li><a href=\"#space-complexity\">Space Complexity</a></li>\n<li><a href=\"#big-o-o1\">Big O: O(1)</a></li>\n<li><a href=\"#big-o-on\">Big O: O(n)</a></li>\n<li><a href=\"#big-o-on2\">Big O: O(n^2)</a></li>\n<li><a href=\"#big-o-drop-non-dominant-terms\">Big O: Drop Non-Dominant Terms</a></li>\n<li><a href=\"#big-o-olog-n\">Big O: O(log n)</a></li>\n<li><a href=\"#what-if-we-have-on-but-with-two-different-arguments\">What if we have O(n) but with two different arguments?</a></li>\n<li><a href=\"#big-o-array-operations\">Big O: Array Operations</a></li>\n<li><a href=\"#better-understanding\">Better understanding</a></li>\n</ul>\n<hr>\n<h2 id=\"big-o-notation\">Big O Notation</h2>\n<p>Big O helps us to determine the efficiency of an algorithm. It describes the worst-case scenario for how an algorithm will perform.</p>\n<p>Big O notation will take into account two areas: time complexity and space complexity.</p>\n<h3 id=\"time-complexity\">Time Complexity</h3>\n<p>We don’t measure the time in seconds, but in the number of operations. If you take the same code and run it on a faster computer, the speed will be different, but the number of operations will be the same.</p>\n<h3 id=\"space-complexity\">Space Complexity</h3>\n<p>We measure the space complexity in the amount of memory that an algorithm uses. So it also can happen that the code use less memory but more time, or vice versa. Therefore your decision on which algorithm to use will depend on the problem you are trying to solve.</p>\n<img src=\"https://www.freecodecamp.org/news/content/images/2021/06/1_KfZYFUT2OKfjekJlCeYvuQ.jpeg\" alt=\"Big O Cheat Sheet\" width=\"600\" style=\"margin: 0 auto;\">\n<hr>\n<h2 id=\"big-o-o1---most-efficient\">Big O: O(1) - Most Efficient 🟢</h2>\n<p>O(1) describes an algorithm that will always execute in the same time (or space) regardless of the size of the input data set.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomethingElse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> n </span><span style=\"color:#F97583\">*</span><span style=\"color:#E1E4E8\"> n;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>It doesn’t matter if <code>n</code> is 1 or 1,000,000, the number of operations will be one <code>O(1)</code>.</p>\n<h2 id=\"big-o-on---medium-efficient\">Big O: O(n) - Medium Efficient 🟡</h2>\n<p>O(n) describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomethingElse</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">array</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> array.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(array[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> array.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(array[j]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span></code></pre>\n<p>The second function will be <code>O(n + n)</code> or <code>O(2n)</code> but we drop the constant, so it will be <code>O(n)</code>. We drop it because it doesn’t matter if it’s 2n or 100n, it will grow linearly.</p>\n<h2 id=\"big-o-on2---less-efficient\">Big O: O(n^2) - Less Efficient 🔴</h2>\n<p>O(n^2) represents an algorithm whose performance is directly proportional to the square of the size of the input data set.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">n</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> n; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(i, j);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"big-o-drop-non-dominant-terms\">Big O: Drop Non-Dominant Terms</h2>\n<p>When you have multiple terms in a Big O notation, you drop the non-dominant terms.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">array</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> array.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> array.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(array[i], array[j]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> array.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(array[i]);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>This will be <code>O(n^2 + n)</code> but:</p>\n<p>N squared is the dominant term, because imagine that <code>n</code> is 100, then <code>n^2</code> is 10,000 and <code>n</code> is 100. So the <code>n</code> term is not relevant.</p>\n<p>So it will result in <code>O(n^2)</code>.</p>\n<h2 id=\"big-o-olog-n---more-efficient\">Big O: O(log n) - More Efficient 🟢</h2>\n<p>Linear Search (<code>O(n)</code>): To find an element, you might have to check every element. For an array of size 8, this could take up to 8 steps.</p>\n<p>Binary Search (<code>O(log n)</code>): Efficiently finds an element by repeatedly dividing the array in half.</p>\n<p>Example</p>\n<p>To find 1 in the array:</p>\n<p><code>1 | 2 | 3 | 4 | 5 | 6 | 7 | 8</code></p>\n<p>Step 1: Compare with middle element <code>4</code>, new search space: <code>1 | 2 | 3 | 4</code></p>\n<p>Step 2: Compare with middle element <code>2</code>, new search space: <code>1 | 2</code></p>\n<p>Step 3: Find <code>1</code></p>\n<p>For <code>8</code> elements, <code>log2(8) = 3</code>, so time complexity is <code>O(log n)</code>. For <code>1,000,000</code> elements, it takes about <code>20</code> steps, making binary search much faster than linear search.</p>\n<h2 id=\"what-if-we-have-on-but-with-two-different-arguments\">What if we have O(n) but with two different arguments?</h2>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">function</span><span style=\"color:#B392F0\"> doSomething</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">a</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">b</span><span style=\"color:#E1E4E8\">){</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; i </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> a; i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(i);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> j </span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\"> 0</span><span style=\"color:#E1E4E8\">; j </span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#E1E4E8\"> b; j</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(j);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>You may think that is <code>O(n)</code> but it’s not. It’s <code>O(a + b)</code> because we are not sure if <code>a</code> and <code>b</code> are the same. So we can’t drop the constant.</p>\n<h2 id=\"big-o-array-operations\">Big O: Array Operations</h2>\n<ul>\n<li>Pushing <code>push()</code> to the end of an array is <code>O(1)</code> because you are just adding an element.</li>\n<li>Popping <code>pop()</code> from the end of an array is <code>O(1)</code> because you are just removing the last element.</li>\n<li>Shifting <code>shift()</code> elements from the beginning of an array is <code>O(n)</code> because you have to re-index all the elements.</li>\n<li>Unshifting <code>unshift()</code> elements to the beginning of an array is <code>O(n)</code> because you have to re-index all the elements.</li>\n<li>Splicing <code>splice()</code> is <code>O(n)</code> because you have to re-index all the elements.</li>\n<li>Concatenating <code>concat()</code> is <code>O(n)</code> because you have to copy all the elements to a new array.</li>\n<li>Sorting <code>sort()</code> is <code>O(n log n)</code> because it uses a comparison sort algorithm.</li>\n</ul>\n<h2 id=\"better-understanding\">Better understanding</h2>\n<p>I have found this answer on <a href=\"https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly\">Stack Overflow</a> that I think it’s a good way to understand it:</p>\n<p><code>O(1)</code> (in the worst case): Given the page that a business’s name is on and the business name, find the phone number.</p>\n<p><code>O(1)</code> (in the average case): Given the page that a person’s name is on and their name, find the phone number.</p>\n<p><code>O(log n)</code>: Given a person’s name, find the phone number by picking a random point about halfway through the part of the book you haven’t searched yet, then checking to see whether the person’s name is at that point. Then repeat the process about halfway through the part of the book where the person’s name lies. (This is a binary search for a person’s name.)</p>\n<p><code>O(n)</code>: Find all people whose phone numbers contain the digit “5”.</p>\n<p><code>O(n)</code>: Given a phone number, find the person or business with that number.</p>\n<p><code>O(n log n)</code>: There was a mix-up at the printer’s office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it’s correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.</p>";

				const frontmatter = {"title":"Big O Notation","summary":"We all know that algorithms are important, but how do we measure their efficiency? Big O notation is here to help us with that.","pubDate":"2024-07-18T00:00:00.000Z","emoji":"💻","author":"Raul Cano","linkAuthor":"https://x.com/raulcanodev","image":"/thumbnails/code.webp","tags":["algorithms","big-o"],"slug":"big-o-notation","category":"Algorithms"};
				const file = "/Users/rawraul/Dev/raul-cano/portfolio-2024/src/content/blog/big-o.md";
				const url = undefined;
				function rawContent() {
					return "## Index\r\n\r\n- [Big O Notation](#big-o-notation)\r\n- [Time Complexity](#time-complexity)\r\n- [Space Complexity](#space-complexity)\r\n- [Big O: O(1)](#big-o-o1)\r\n- [Big O: O(n)](#big-o-on)\r\n- [Big O: O(n^2)](#big-o-on2)\r\n- [Big O: Drop Non-Dominant Terms](#big-o-drop-non-dominant-terms)\r\n- [Big O: O(log n)](#big-o-olog-n)\r\n- [What if we have O(n) but with two different arguments?](#what-if-we-have-on-but-with-two-different-arguments)\r\n- [Big O: Array Operations](#big-o-array-operations)\r\n- [Better understanding](#better-understanding)\r\n---\r\n## Big O Notation\r\n\r\nBig O helps us to determine the efficiency of an algorithm. It describes the worst-case scenario for how an algorithm will perform. \r\n\r\nBig O notation will take into account two areas: time complexity and space complexity.\r\n\r\n### Time Complexity\r\n\r\nWe don't measure the time in seconds, but in the number of operations. If you take the same code and run it on a faster computer, the speed will be different, but the number of operations will be the same.\r\n\r\n### Space Complexity\r\n\r\nWe measure the space complexity in the amount of memory that an algorithm uses. So it also can happen that the code use less memory but more time, or vice versa. Therefore your decision on which algorithm to use will depend on the problem you are trying to solve.\r\n\r\n\r\n<img src=\"https://www.freecodecamp.org/news/content/images/2021/06/1_KfZYFUT2OKfjekJlCeYvuQ.jpeg\" alt=\"Big O Cheat Sheet\" width=\"600\" style=\"margin: 0 auto;\" />\r\n\r\n---\r\n\r\n## Big O: O(1) - Most Efficient 🟢\r\n\r\nO(1) describes an algorithm that will always execute in the same time (or space) regardless of the size of the input data set. \r\n\r\n```javascript\r\nfunction doSomething(n) {\r\n  return n + n;\r\n}\r\n\r\nfunction doSomethingElse(n) {\r\n  return n * n;\r\n}\r\n```\r\nIt doesn't matter if `n` is 1 or 1,000,000, the number of operations will be one `O(1)`.\r\n\r\n## Big O: O(n) - Medium Efficient 🟡\r\n\r\nO(n) describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.\r\n\r\n```javascript\r\nfunction doSomething(n){\r\n  for (let i = 0; i < n; i++) {\r\n    console.log(i);\r\n  }\r\n}\r\n\r\nfunction doSomethingElse(array) {\r\n  for (let i = 0; i < array.length; i++) {\r\n    console.log(array[i]);\r\n  }\r\n  for (let j = 0; j < array.length; j++) {\r\n    console.log(array[j]);\r\n  }\r\n\r\n```\r\nThe second function will be `O(n + n)` or `O(2n)` but we drop the constant, so it will be `O(n)`. We drop it because it doesn’t matter if it’s 2n or 100n, it will grow linearly.\r\n\r\n## Big O: O(n^2) - Less Efficient 🔴\r\n\r\nO(n^2) represents an algorithm whose performance is directly proportional to the square of the size of the input data set. \r\n\r\n```javascript\r\nfunction doSomething(n) {\r\n  for (let i = 0; i < n; i++) {\r\n    for (let j = 0; j < n; j++) {\r\n      console.log(i, j);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Big O: Drop Non-Dominant Terms \r\n\r\nWhen you have multiple terms in a Big O notation, you drop the non-dominant terms. \r\n\r\n```javascript\r\nfunction doSomething(array) {\r\n  for (let i = 0; i < array.length; i++) {\r\n    for (let j = 0; j < array.length; j++) {\r\n      console.log(array[i], array[j]);\r\n    }\r\n  }\r\n  for (let i = 0; i < array.length; i++) {\r\n    console.log(array[i]);\r\n  }\r\n}\r\n```\r\nThis will be `O(n^2 + n)` but:\r\n\r\nN squared is the dominant term, because imagine that `n` is 100, then `n^2` is 10,000 and `n` is 100. So the `n` term is not relevant.\r\n\r\nSo it will result in `O(n^2)`.\r\n\r\n## Big O: O(log n) - More Efficient 🟢\r\n\r\nLinear Search (`O(n)`): To find an element, you might have to check every element. For an array of size 8, this could take up to 8 steps.\r\n\r\nBinary Search (`O(log n)`): Efficiently finds an element by repeatedly dividing the array in half.\r\n\r\nExample\r\n\r\nTo find 1 in the array:\r\n\r\n`1 | 2 | 3 | 4 | 5 | 6 | 7 | 8`\r\n\r\nStep 1: Compare with middle element `4`, new search space: `1 | 2 | 3 | 4`\r\n\r\nStep 2: Compare with middle element `2`, new search space: `1 | 2`\r\n\r\nStep 3: Find `1`\r\n\r\nFor `8` elements, `log2(8) = 3`, so time complexity is `O(log n)`. For `1,000,000` elements, it takes about `20` steps, making binary search much faster than linear search.\r\n\r\n## What if we have O(n) but with two different arguments? \r\n\r\n```javascript\r\nfunction doSomething(a, b){\r\n  for (let i = 0; i < a; i++) {\r\n    console.log(i);\r\n  }\r\n  for (let j = 0; j < b; j++) {\r\n    console.log(j);\r\n  }\r\n}\r\n```\r\n\r\nYou may think that is `O(n)` but it's not. It's `O(a + b)` because we are not sure if `a` and `b` are the same. So we can't drop the constant.\r\n\r\n\r\n\r\n\r\n## Big O: Array Operations\r\n\r\n- Pushing `push()` to the end of an array is `O(1)` because you are just adding an element. \r\n- Popping `pop()` from the end of an array is `O(1)` because you are just removing the last element.\r\n- Shifting `shift()` elements from the beginning of an array is `O(n)` because you have to re-index all the elements.\r\n- Unshifting `unshift()` elements to the beginning of an array is `O(n)` because you have to re-index all the elements.\r\n- Splicing `splice()` is `O(n)` because you have to re-index all the elements.\r\n- Concatenating `concat()` is `O(n)` because you have to copy all the elements to a new array.\r\n- Sorting `sort()` is `O(n log n)` because it uses a comparison sort algorithm.\r\n\r\n\r\n## Better understanding\r\n\r\nI have found this answer on [Stack Overflow](https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly) that I think it's a good way to understand it:\r\n\r\n`O(1)` (in the worst case): Given the page that a business's name is on and the business name, find the phone number.\r\n\r\n`O(1)` (in the average case): Given the page that a person's name is on and their name, find the phone number.\r\n\r\n`O(log n)`: Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, then checking to see whether the person's name is at that point. Then repeat the process about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)\r\n\r\n`O(n)`: Find all people whose phone numbers contain the digit \"5\".\r\n\r\n`O(n)`: Given a phone number, find the person or business with that number.\r\n\r\n`O(n log n)`: There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.\r\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"index","text":"Index"},{"depth":2,"slug":"big-o-notation","text":"Big O Notation"},{"depth":3,"slug":"time-complexity","text":"Time Complexity"},{"depth":3,"slug":"space-complexity","text":"Space Complexity"},{"depth":2,"slug":"big-o-o1---most-efficient","text":"Big O: O(1) - Most Efficient 🟢"},{"depth":2,"slug":"big-o-on---medium-efficient","text":"Big O: O(n) - Medium Efficient 🟡"},{"depth":2,"slug":"big-o-on2---less-efficient","text":"Big O: O(n^2) - Less Efficient 🔴"},{"depth":2,"slug":"big-o-drop-non-dominant-terms","text":"Big O: Drop Non-Dominant Terms"},{"depth":2,"slug":"big-o-olog-n---more-efficient","text":"Big O: O(log n) - More Efficient 🟢"},{"depth":2,"slug":"what-if-we-have-on-but-with-two-different-arguments","text":"What if we have O(n) but with two different arguments?"},{"depth":2,"slug":"big-o-array-operations","text":"Big O: Array Operations"},{"depth":2,"slug":"better-understanding","text":"Better understanding"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
